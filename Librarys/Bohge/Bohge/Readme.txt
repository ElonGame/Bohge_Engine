2.是有opengl 坐标系， 右手法则，以显示器平面为中心轴，Z轴向使用者射出方向为Z，向里为-Z
3.架构一般流程
	1)UI按键响应
	2)
	3)
	4)
	5)
4.整个游戏的坐标和大小都使用的是相对坐标系，这样保证在不同分辨率的设备下的可移植性
	1)坐标系统按照opengl屏幕空间坐标系统原点在中心
	2)尺寸系统按照纹理系统来，意思就是整个屏幕空间是00-11范畴
5, 纹理坐标的原点在左上角和DX坐标系一致，为了计算地形等纹理时候方便
6, 关于右手笛卡尔坐标系的 x-, y- 和 z-轴的旋转分别叫做 pitch, yaw 和 roll 旋转
7，问题，缩放会对UI的设置中心产生影响，以后修改
8，android下在其他线程是无法访问engine中的内容的
9, android全部要用/反斜杠
10,需要外部实现
	extern void Keyborad(const vector4f& rect, const std::wstring& was, bool isNumberOnly  );函数，响应文本输入
	extern void RefreshItem();//刷新物品
	extern void IAPBuyItem(int index);//响应购买物品行为
11，全部输入模型的up方向必须是(0,1,0),Froward方向必须要(1,0,0)
12, 你new的你删除，调用其它方式得到的指针，引擎负责删除
13, 推荐使用米单位
14, 雾使用的是gl_Position.w;线性的深度，但是对于正交投影为主摄像机投影的会导致bug，切记
15, shadow map在做阴影的时候不同的投影矩阵处理不一样，透视的a44不为1，所以要把计算的纹理坐标处以w,但是实际上有Texture2DProj是可以除去的，
	我怀疑在for循环采样有bug
16，整个runtime阴影系统计算线性化深度是在顶点中计算的，当背投影物体顶点间距过大的时候由于现在的线性深的计算方法会导致深度插值错误，如果遇到深度不正确的情况可以将深度计算放入ps中，但是这样可能会加大开销